<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lambda | Notas de Cloud y DevOps</title><link>https://blog.okelet.com/tags/lambda/</link><atom:link href="https://blog.okelet.com/tags/lambda/index.xml" rel="self" type="application/rss+xml"/><description>Lambda</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>es-ES</language><copyright>[CC BY-SA](https://creativecommons.org/licenses/by-sa/3.0/) Juan A. S. 2020</copyright><lastBuildDate>Sun, 01 Sep 2019 00:00:00 +0000</lastBuildDate><image><url>img/map[gravatar:%!s(bool=false) shape:circle]</url><title>Lambda</title><link>https://blog.okelet.com/tags/lambda/</link></image><item><title>Monitorizar memoria y errores de funciones Lambda</title><link>https://blog.okelet.com/post/2019/09/monitorizar-memoria-y-errores-de-funciones-lambda/</link><pubDate>Sun, 01 Sep 2019 00:00:00 +0000</pubDate><guid>https://blog.okelet.com/post/2019/09/monitorizar-memoria-y-errores-de-funciones-lambda/</guid><description>&lt;p>A la hora de monitorizar estadísticas sobre la ejecución de nuestras funciones Lambda, Cloudwatch ya nos ofrece algunas &lt;em>builtin&lt;/em> como:&lt;/p>
&lt;ul>
&lt;li>Cantidad de &lt;em>throttles&lt;/em>&lt;/li>
&lt;li>Número de invocaciones&lt;/li>
&lt;li>Número de errores &amp;ldquo;genéricos&amp;rdquo;&lt;/li>
&lt;li>Duración (media y total)&lt;/li>
&lt;/ul>
&lt;p>Pero si queremos ver estadísticas sobre memoria o errores según sean por consumo excesivo de memoria o por timeout, no los tenemos disponibles por defecto.&lt;/p>
&lt;p>Para conseguir información de este tipo de errores, tendremos que recurrir a crear
&lt;a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/MonitoringPolicyExamples.html" target="_blank" rel="noopener">filtros de métricas (&lt;em>metric filters&lt;/em>)&lt;/a> de los LOGs que deja Lambda en Cloudwatch. Por ejemplo, con el siguiente script, recorremos todas los grupos de LOGs de Lambda (aquellos que empiezan por &lt;code>/aws/lambda/&lt;/code>) y creamos unas cuantas métricas en cada uno de ellos, para poder después obtener estadísticas:&lt;/p>
&lt;pre>&lt;code class="language-bash">#!/bin/bash
# Based on https://gist.github.com/sandfox/337129afa5555af6372d4eae536b20f0
prefix=&amp;quot;/aws/lambda/&amp;quot;
for log_group in $(aws logs describe-log-groups --log-group-name-prefix $prefix --query &amp;quot;logGroups[].logGroupName&amp;quot; --output text) ; do
fn_name=${log_group#$prefix};
aws logs put-metric-filter \
--log-group-name &amp;quot;$log_group&amp;quot; \
--filter-name lambda-memory-usage \
--filter-pattern '[ x=&amp;quot;REPORT&amp;quot;, x=&amp;quot;RequestId:&amp;quot;, request_id, x=&amp;quot;Duration:&amp;quot;, duration, x=&amp;quot;ms&amp;quot;, x=&amp;quot;Billed&amp;quot;, x=&amp;quot;Duration:&amp;quot;, billed_duration, x=&amp;quot;ms&amp;quot;, x=&amp;quot;Memory&amp;quot;, x=&amp;quot;Size:&amp;quot;, memory_size, x=&amp;quot;MB&amp;quot;, x=&amp;quot;Max&amp;quot;, x=&amp;quot;Memory&amp;quot;, x=&amp;quot;Used:&amp;quot;, memory_used, x=&amp;quot;MB&amp;quot;]' \
--metric-transformations &amp;quot;metricNamespace=Custom/Lambda,metricName=${fn_name}-MemoryUsed,metricValue=\$memory_used&amp;quot;
aws logs put-metric-filter \
--log-group-name &amp;quot;$log_group&amp;quot; \
--filter-name lambda-memory-size \
--filter-pattern '[ x=&amp;quot;REPORT&amp;quot;, x=&amp;quot;RequestId:&amp;quot;, request_id, x=&amp;quot;Duration:&amp;quot;, duration, x=&amp;quot;ms&amp;quot;, x=&amp;quot;Billed&amp;quot;, x=&amp;quot;Duration:&amp;quot;, billed_duration, x=&amp;quot;ms&amp;quot;, x=&amp;quot;Memory&amp;quot;, x=&amp;quot;Size:&amp;quot;, memory_size, x=&amp;quot;MB&amp;quot;, x=&amp;quot;Max&amp;quot;, x=&amp;quot;Memory&amp;quot;, x=&amp;quot;Used:&amp;quot;, memory_used, x=&amp;quot;MB&amp;quot;]' \
--metric-transformations &amp;quot;metricNamespace=Custom/Lambda,metricName=${fn_name}-MemorySize,metricValue=\$memory_size&amp;quot;
# Errores que se dan cuando la ejecución se pasa del máximo de memoria permitido
aws logs put-metric-filter \
--log-group-name &amp;quot;${log_group}&amp;quot; \
--filter-name lambda-memory-errors \
--filter-pattern 'Process exited before completing request' \
--metric-transformations &amp;quot;metricNamespace=Custom/Lambda,metricName=${fn_name}-MemoryErrors,metricValue=1,defaultValue=0&amp;quot;
# Errores que se dan cuando la ejecución se pasa del máximo de tiempo permitido
aws logs put-metric-filter \
--log-group-name &amp;quot;${log_group}&amp;quot; \
--filter-name lambda-timeout-errors \
--filter-pattern 'Task timed out after' \
--metric-transformations &amp;quot;metricNamespace=Custom/Lambda,metricName=${fn_name}-TimeoutErrors,metricValue=1,defaultValue=0&amp;quot;
done
&lt;/code>&lt;/pre>
&lt;p>Una vez creados, y pasados cierto tiempo para poder obtener datos, en la sección de métricas de Cloudwatch, tendremos una nueva categoría, &lt;code>Custom/Lambda&lt;/code>, donde tendremos el listado de nuevas métricas, por cada función Lambda:&lt;/p>
&lt;p>&lt;img src="cloudwatch_lambda_custom_namespace.png" alt="">&lt;/p>
&lt;p>Podremos seleccionar estas estadísticas para poder visualizar los datos en un gráfico:&lt;/p>
&lt;p>&lt;img src="cloudwatch_lambda_memory_used_graph.png" alt="">&lt;/p>
&lt;p>También podremos consultar estos datos desde la CLI:&lt;/p>
&lt;pre>&lt;code class="language-bash">aws cloudwatch get-metric-statistics --namespace Custom/Lambda --metric-name my_function_name-MemoryUsed --start-time $(date --date &amp;quot;1 day ago&amp;quot; +%s) --end-time $(date +%s) --period 300 --statistics Average
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-json">{
&amp;quot;Label&amp;quot;: &amp;quot;my_function_name-MemoryUsed&amp;quot;,
&amp;quot;Datapoints&amp;quot;: [
{
&amp;quot;Timestamp&amp;quot;: &amp;quot;2019-08-29T04:10:00Z&amp;quot;,
&amp;quot;Average&amp;quot;: 84.32894736842105,
&amp;quot;Unit&amp;quot;: &amp;quot;None&amp;quot;
},
{
&amp;quot;Timestamp&amp;quot;: &amp;quot;2019-08-28T18:10:00Z&amp;quot;,
&amp;quot;Average&amp;quot;: 82.94736842105263,
&amp;quot;Unit&amp;quot;: &amp;quot;None&amp;quot;
},
{
&amp;quot;Timestamp&amp;quot;: &amp;quot;2019-08-29T08:10:00Z&amp;quot;,
&amp;quot;Average&amp;quot;: 83.72368421052632,
&amp;quot;Unit&amp;quot;: &amp;quot;None&amp;quot;
},
{
&amp;quot;Timestamp&amp;quot;: &amp;quot;2019-08-28T22:10:00Z&amp;quot;,
&amp;quot;Average&amp;quot;: 84.63157894736842,
&amp;quot;Unit&amp;quot;: &amp;quot;None&amp;quot;
},
{
&amp;quot;Timestamp&amp;quot;: &amp;quot;2019-08-29T12:10:00Z&amp;quot;,
&amp;quot;Average&amp;quot;: 83.59210526315789,
&amp;quot;Unit&amp;quot;: &amp;quot;None&amp;quot;
},
{
&amp;quot;Timestamp&amp;quot;: &amp;quot;2019-08-29T02:10:00Z&amp;quot;,
&amp;quot;Average&amp;quot;: 83.17105263157895,
&amp;quot;Unit&amp;quot;: &amp;quot;None&amp;quot;
},
{
&amp;quot;Timestamp&amp;quot;: &amp;quot;2019-08-28T16:10:00Z&amp;quot;,
&amp;quot;Average&amp;quot;: 84.35526315789474,
&amp;quot;Unit&amp;quot;: &amp;quot;None&amp;quot;
},
{
&amp;quot;Timestamp&amp;quot;: &amp;quot;2019-08-29T06:10:00Z&amp;quot;,
&amp;quot;Average&amp;quot;: 83.85526315789474,
&amp;quot;Unit&amp;quot;: &amp;quot;None&amp;quot;
},
{
&amp;quot;Timestamp&amp;quot;: &amp;quot;2019-08-29T10:10:00Z&amp;quot;,
&amp;quot;Average&amp;quot;: 84.48684210526316,
&amp;quot;Unit&amp;quot;: &amp;quot;None&amp;quot;
},
{
&amp;quot;Timestamp&amp;quot;: &amp;quot;2019-08-28T20:10:00Z&amp;quot;,
&amp;quot;Average&amp;quot;: 85.0657894736842,
&amp;quot;Unit&amp;quot;: &amp;quot;None&amp;quot;
},
{
&amp;quot;Timestamp&amp;quot;: &amp;quot;2019-08-29T00:10:00Z&amp;quot;,
&amp;quot;Average&amp;quot;: 84.97368421052632,
&amp;quot;Unit&amp;quot;: &amp;quot;None&amp;quot;
},
{
&amp;quot;Timestamp&amp;quot;: &amp;quot;2019-08-29T14:10:00Z&amp;quot;,
&amp;quot;Average&amp;quot;: 82.57894736842105,
&amp;quot;Unit&amp;quot;: &amp;quot;None&amp;quot;
}
]
}
&lt;/code>&lt;/pre></description></item><item><title>Crear custom runtime para PHP en AWS Lambda</title><link>https://blog.okelet.com/post/2019/06/crear-custom-runtime-para-php-en-aws-lambda/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://blog.okelet.com/post/2019/06/crear-custom-runtime-para-php-en-aws-lambda/</guid><description>&lt;p>Actualización 2019-06-27: Añadida extensión para MongoDB.&lt;/p>
&lt;p>En el proyecto que estamos desarrollando, tenemos algunas funciones Lambda en Python, con las que no tenemos problemas (por ahora); las dependencias de estas funciones Python las gestionamos con
&lt;a href="https://docs.pipenv.org/en/latest/" target="_blank" rel="noopener">pipenv&lt;/a>.&lt;/p>
&lt;p>Pero dado que el frontend está desarrollado en PHP, hay veces que necesitamos acceder a determinadas propiedades y funciones desde las funciones Lambda, y nos planteamos migrar o desarrollar nuevas funciones Lambda en PHP. Esto no era posible hasta que hace unos meses, AWS anunció el soporte de
&lt;a href="https://aws.amazon.com/es/blogs/apn/aws-lambda-custom-runtime-for-php-a-practical-example/" target="_blank" rel="noopener">&lt;em>custom runtimes&lt;/em>&lt;/a>, que básicamente consiste en subir el ejecutable con un determinado nombre.&lt;/p>
&lt;p>En resumen, lo que el post anterior viene a decir es que:&lt;/p>
&lt;ul>
&lt;li>Tenemos que compilar PHP&lt;/li>
&lt;li>Tenemos que crear un script llamado &lt;code>bootstrap&lt;/code> que será al que llame Lambda; este script será el encargado de conectarse a un endpoint &amp;ldquo;mágico&amp;rdquo; (&lt;code>http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/next&lt;/code>), que nos devolverá un JSON con las propiedades de la petición a procesar. Este JSON se lo podemos pasar entonces a una función PHP de nuestra elección.&lt;/li>
&lt;/ul>
&lt;p>Un ejemplo de fichero &lt;code>bootstrap&lt;/code> se encuentra en
&lt;a href="https://gist.github.com/okelet/afe16efea9b89ce90e4690dd752cb4ae" target="_blank" rel="noopener">este gist&lt;/a>:&lt;/p>
&lt;script type="application/javascript" src="https://gist.github.com/okelet/afe16efea9b89ce90e4690dd752cb4ae.js">&lt;/script>
&lt;p>El motivo de este post, es que
&lt;a href="https://aws.amazon.com/blogs/compute/upcoming-updates-to-the-aws-lambda-execution-environment/" target="_blank" rel="noopener">AWS ha publicado una noticia&lt;/a> diciendo que va a cambiar la imagen base donde se ejecutan los &lt;em>custom runtimes&lt;/em>. Hasta ahora se basaba en una Amazon Linux 2017.03, pero a partir de ahora se van a ejecutar sobre una Amazon Linux 2018.03; esto puede causar que determinados &lt;em>runtimes&lt;/em> dejen de funcionar, si están compilados con versiones determinadas de librerías del sistema operativo.&lt;/p>
&lt;p>Ya tenía hecho un scriptillo para la versión antigua del runtime, pero como tenía que revisarlo, he decidido &amp;ldquo;ponerlo bonito&amp;rdquo; y publicarlo en el blog. Manos a la obra.&lt;/p>
&lt;p>Lo primero que tenemos que hacer es determinar una imagen de Docker válida para la imagen donde se ejecutaría el &lt;em>runtime&lt;/em>; en nuestro caso,
&lt;a href="https://docs.aws.amazon.com/es_es/lambda/latest/dg/current-supported-versions.html" target="_blank" rel="noopener">según la documentación&lt;/a> sería una AMI Linux 2018.03, y yendo al Docker Hub, podemos ver la versión de la
&lt;a href="https://hub.docker.com/_/amazonlinux" target="_blank" rel="noopener">imagen Docker equivalente&lt;/a>.&lt;/p>
&lt;p>Una vez que sabemos la imagen Docker, lanzamos un contenedor:&lt;/p>
&lt;pre>&lt;code class="language-bash">docker run -it --name php-lambda-layer --rm amazonlinux:2018.03.0.20190514 bash
&lt;/code>&lt;/pre>
&lt;p>Una vez lanzado, lo primero que haremos será actualizar el sistema e instalar una serie de librerías necesarias para compilar PHP y las dependencias que queremos:&lt;/p>
&lt;pre>&lt;code class="language-bash">cd
yum update -y
yum install autoconf bison gcc gcc-c++ libcurl-devel libxml2-devel openssl-devel git tree zip vim python36 python36-pip libicu-devel unzip diff libpng-devel -y
&lt;/code>&lt;/pre>
&lt;p>A continuación, nos bajamos la última versión de PHP y la compilamos, indicando los módulos que queremos incluir:&lt;/p>
&lt;pre>&lt;code class="language-bash">cd
git clone https://github.com/mongodb/mongo-php-driver.git mongodb
cd mongodb
git checkout 1.5.5
git submodule update --init
cd
mkdir ~/php-7-bin
curl -sL https://github.com/php/php-src/archive/php-7.3.6.tar.gz | tar -xz
cd ~/php-src-php-7.3.6
mv ~/mongodb ext/mongodb
./buildconf --force
./configure --prefix=/root/php-7-bin/ --with-openssl --enable-intl --enable-mbstring --with-pdo-mysql --with-curl --with-zlib --with-gd --enable-bcmath --enable-mongodb --without-pear
make
make install
~/php-7-bin/bin/php -v
~/php-7-bin/bin/php -m
rm -Rf ~/php-7-bin/{include,lib,php,var}
rm -Rf ~/php-7-bin/bin/{php-cgi,phpdbg}
&lt;/code>&lt;/pre>
&lt;p>Con los parámetros anteriores al compilar, tendremos PHP con los siguientes módulos:&lt;/p>
&lt;ul>
&lt;li>openssl&lt;/li>
&lt;li>curl&lt;/li>
&lt;li>intl&lt;/li>
&lt;li>mbstring&lt;/li>
&lt;li>pdo/mysql&lt;/li>
&lt;li>gd&lt;/li>
&lt;li>bcmath&lt;/li>
&lt;li>mongodb&lt;/li>
&lt;li>&lt;del>zip&lt;/del> (&lt;a href="https://stackoverflow.com/questions/55394273/building-php-with-libzip-for-aws-lambda-layer">https://stackoverflow.com/questions/55394273/building-php-with-libzip-for-aws-lambda-layer&lt;/a>)&lt;/li>
&lt;/ul>
&lt;p>Tras esto, nos bajamos
&lt;a href="https://getcomposer.org/" target="_blank" rel="noopener">composer&lt;/a>; lo utilizaremos para utilizar la librería
&lt;a href="https://packagist.org/packages/guzzlehttp/guzzle" target="_blank" rel="noopener">guzzlehttp/guzzle&lt;/a> para facilitar la manera en la que obtenemos el evento y reportar el estado (y no estar peleando con llamadas a &lt;code>curl&lt;/code>):&lt;/p>
&lt;pre>&lt;code class="language-bash">cd
curl -sS https://getcomposer.org/installer | ~/php-7-bin/bin/php
&lt;/code>&lt;/pre>
&lt;p>Lo siguiente sería crear un proyecto de &lt;code>composer&lt;/code> e instalar la dependencia mencionada antes; al mismo tiempo, también nos bajamos el fichero &lt;code>bootstrap&lt;/code> que será el punto de entrada de nuestro &lt;em>runtime&lt;/em>.&lt;/p>
&lt;pre>&lt;code class="language-bash">mkdir ~/php-runtime
cd ~/php-runtime
curl -qL https://gist.github.com/okelet/afe16efea9b89ce90e4690dd752cb4ae/raw &amp;gt; bootstrap
chmod 755 bootstrap
~/php-7-bin/bin/php ~/composer.phar require guzzlehttp/guzzle
&lt;/code>&lt;/pre>
&lt;p>Por último, lo metemos todo en un fichero ZIP comprimido&lt;/p>
&lt;pre>&lt;code class="language-bash">rm -f ~/runtime.zip
cd ~/php-7-bin
zip -r ~/runtime.zip bin/php
cd ~/php-runtime
zip -r ~/runtime.zip .
&lt;/code>&lt;/pre>
&lt;p>La estructura final de este fichero ZIP es la siguiente:&lt;/p>
&lt;pre>&lt;code>├── bin
│   └── php
├── bootstrap
├── composer.json
├── composer.lock
└── vendor
├── autoload.php
├── composer
├── guzzlehttp
├── psr
└── ralouphie
&lt;/code>&lt;/pre>
&lt;p>Antes de finalizar el contenedor, desde una shell externa, copiaremos el fichero generado:&lt;/p>
&lt;pre>&lt;code class="language-bash">docker cp php-lambda-layer:/root/runtime.zip .
&lt;/code>&lt;/pre>
&lt;p>Ahora subimos la capa (&lt;code>layer&lt;/code>) a AWS:&lt;/p>
&lt;pre>&lt;code class="language-bash">aws lambda publish-layer-version --layer-name php-cake-amzlx201803 --zip-file fileb://runtime.zip --compatible-runtimes provided --region eu-west-1
&lt;/code>&lt;/pre>
&lt;p>Lo único que nos quedaría sería subir la función en PHP, indicando que queremos usar un &lt;em>custom runtime&lt;/em> y añadirle este &lt;code>layer&lt;/code> que hemos subido.&lt;/p>
&lt;p>Hay que tener en cuenta que el script &lt;code>bootstrap&lt;/code> hace un mapeo entre el directorio &lt;code>src&lt;/code> y el &lt;code>namespace&lt;/code> &lt;code>App&lt;/code>, de modo que si especificamos &lt;code>App\Lambda\MyFunction::handler&lt;/code> como &lt;code>handler&lt;/code> (en la configuración de la función Lambda), buscaría un fichero &lt;code>src/Lambda/MyFunction.php&lt;/code>, que debería contener una función estática &lt;code>handler&lt;/code>, que aceptaría un único parámetro, que sería el evento; algo así como:&lt;/p>
&lt;pre>&lt;code class="language-php">&amp;lt;?php
namespace App\Lambda;
require dirname(__DIR__) . '/../vendor/autoload.php';
class MyFunction
{
public static function handler($event)
{
return &amp;quot;Hello &amp;quot; . $event[&amp;quot;name&amp;quot;] . &amp;quot;!; full event is &amp;quot; . json_encode($event);
}
public static function runner() {
return self::handler([
&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;Foo&amp;quot;,
&amp;quot;email&amp;quot; =&amp;gt; &amp;quot;no@reply.com&amp;quot;,
&amp;quot;groups&amp;quot; =&amp;gt; [
[
&amp;quot;id&amp;quot; =&amp;gt; 1,
&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;admin&amp;quot;
],
[
&amp;quot;id&amp;quot; =&amp;gt; 8,
&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;bar&amp;quot;
]
]
]);
}
}
&lt;/code>&lt;/pre>
&lt;p>La función &lt;code>runner&lt;/code> es una función de ayuda para desarrollar en local, de tal forma que podamos indicar dentro de ella el evento al llamar a la función &lt;code>handler&lt;/code>, ejecutándolo de la siguiente forma:&lt;/p>
&lt;pre>&lt;code class="language-bash">php -r &amp;quot;require 'src/Lambda/MyFunction.php' ; print_r(call_user_func('App\Lambda\MyFunction::runner'));&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Referencias:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://aws.amazon.com/blogs/compute/upcoming-updates-to-the-aws-lambda-execution-environment/">https://aws.amazon.com/blogs/compute/upcoming-updates-to-the-aws-lambda-execution-environment/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://aws.amazon.com/blogs/compute/updated-timeframe-for-the-upcoming-aws-lambda-and-aws-lambdaedge-execution-environment-update/">https://aws.amazon.com/blogs/compute/updated-timeframe-for-the-upcoming-aws-lambda-and-aws-lambdaedge-execution-environment-update/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://aws.amazon.com/es/blogs/apn/aws-lambda-custom-runtime-for-php-a-practical-example/">https://aws.amazon.com/es/blogs/apn/aws-lambda-custom-runtime-for-php-a-practical-example/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developpaper.com/aliyun-centos-7-6-install-php7-3/">https://developpaper.com/aliyun-centos-7-6-install-php7-3/&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>