<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ECR | Mis notas</title><link>https://blog.okelet.com/tags/ecr/</link><atom:link href="https://blog.okelet.com/tags/ecr/index.xml" rel="self" type="application/rss+xml"/><description>ECR</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>es-es</language><lastBuildDate>Sat, 18 Jan 2020 00:00:00 +0000</lastBuildDate><image><url>img/map[gravatar:%!s(bool=false) shape:circle]</url><title>ECR</title><link>https://blog.okelet.com/tags/ecr/</link></image><item><title>Configurar Microk8s para usar repositorios de AWS ECR</title><link>https://blog.okelet.com/posts/2020/01/configurar-microk8s-para-usar-repositorios-de-aws-ecr/</link><pubDate>Sat, 18 Jan 2020 00:00:00 +0000</pubDate><guid>https://blog.okelet.com/posts/2020/01/configurar-microk8s-para-usar-repositorios-de-aws-ecr/</guid><description>&lt;p>Continuando con un post anterior de cómo
&lt;a href="https://blog.okelet.com/posts/2019/06/probando-ansible-awx-con-microk8s/">probar Ansible AWX con Microk8s&lt;/a> (en AWS EC2). Bueno, pues resulta que me creé una imagen personalizada para el contener &lt;code>awx_task&lt;/code> para instalar una serie de librerías y comandos que necesitaba para lanzar unos playbooks; el fichero &lt;code>Dockerfile&lt;/code> es similar a éste:&lt;/p>
&lt;pre>&lt;code class="language-text">FROM ansible/awx_task:9.1.1
# Switch user to become root
USER 0
# Additional software
RUN cd &amp;amp;&amp;amp; \
set -x &amp;amp;&amp;amp; \
dnf install -y nmap-ncat htop &amp;amp;&amp;amp; \
dnf clean all
# Ansible venv additional dependencies
RUN cd &amp;amp;&amp;amp; \
source /var/lib/awx/venv/ansible/bin/activate &amp;amp;&amp;amp; \
umask 0022 &amp;amp;&amp;amp; \
pip install --upgrade pypsrp pysocks &amp;amp;&amp;amp; \
deactivate
# Restore the original user
# https://github.com/ansible/awx/blob/devel/installer/roles/image_build/templates/Dockerfile.task.j2
USER 1000
&lt;/code>&lt;/pre>
&lt;p>Y me creé un repositorio en
&lt;a href="https://aws.amazon.com/es/ecr/" target="_blank" rel="noopener">AWS ECR&lt;/a>. Después generé la imagen y la subí al repositorio (siendo &lt;code>xxxxxxxxxxx&lt;/code> el ID de la cuenta de AWS):&lt;/p>
&lt;pre>&lt;code class="language-bash">$(aws ecr get-login --no-include-email)
docker build --force-rm --pull --no-cache -t xxxxxxxxxxx.dkr.ecr.eu-west-1.amazonaws.com/ansible/awx_task:9.1.1 .
docker push xxxxxxxxxxx.dkr.ecr.eu-west-1.amazonaws.com/ansible/awx_task:9.1.1
&lt;/code>&lt;/pre>
&lt;p>Tras esto modifiqué el fichero de inventario que usa el instalador de AWX para hacer referencia a la imagen que acabo de subir y crear.&lt;/p>
&lt;pre>&lt;code class="language-yaml">kubernetes_task_image=xxxxxxxxxxx.dkr.ecr.eu-west-1.amazonaws.com/ansible/awx_task
&lt;/code>&lt;/pre>
&lt;p>Pero cuando el cluster de Kubernetes intenta obtener la imagen para crear el pod, se queda en estado &lt;code>ErrImagePull&lt;/code> con el mensaje:&lt;/p>
&lt;pre>&lt;code class="language-text"> Normal Pulling 2s (x3 over 46s) kubelet, pcjuan Pulling image &amp;quot;xxxxxxxxxxx.dkr.ecr.eu-west-1.amazonaws.com/ansible/awx_task:9.1.1&amp;quot;
Warning Failed 2s (x3 over 45s) kubelet, pcjuan Failed to pull image &amp;quot;xxxxxxxxxxx.dkr.ecr.eu-west-1.amazonaws.com/ansible/awx_task:9.1.1&amp;quot;: rpc error: code = Unknown desc = failed to resolve image &amp;quot;xxxxxxxxxxx.dkr.ecr.eu-west-1.amazonaws.com/ansible/awx_task:9.1.1&amp;quot;: no available registry endpoint: unexpected status code https://xxxxxxxxxxx.dkr.ecr.eu-west-1.amazonaws.com/v2/ansible/awx_task/manifests/9.1.1: 401 Unauthorized
Warning Failed 2s (x3 over 45s) kubelet, pcjuan Error: ErrImagePull
&lt;/code>&lt;/pre>
&lt;p>Esto se debe a que Kubernetes no tiene las credenciales necesarias para acceder al repositorio. Pero después de investigar, es fácil solucionarlo. Lo primero que tenemos que hacer es crear un &lt;code>cronjob&lt;/code> en Kubernetes (lo haremos con un crojob porque realmente lo que usa Docker es un token, que tiene caducidad, y hay que renovarlo cada cierto tiempo), para que haga login en el repositorio, y cree una credencial para obtener de forma correcta la imagen; para esto, crearemos un fichero llamado &lt;code>ecr-cred-refresh.yml&lt;/code> con el siguiente contenido:&lt;/p>
&lt;pre>&lt;code class="language-yaml">apiVersion: batch/v1beta1
kind: CronJob
metadata:
name: ecr-cred-helper
spec:
concurrencyPolicy: Allow
schedule: 0 */6 * * *
failedJobsHistoryLimit: 1
successfulJobsHistoryLimit: 3
suspend: false
jobTemplate:
spec:
template:
spec:
containers:
- command:
- /bin/sh
- -c
- |-
NAMESPACE=awx
SERVICE_ACCOUNT=awx
ACCOUNT=$(aws sts get-caller-identity --query 'Account' --output text)
REGION=$(curl -s http://169.254.169.254/latest/dynamic/instance-identity/document | python -c &amp;quot;import json,sys; print(json.loads(sys.stdin.read())['region'])&amp;quot;)
SECRET_NAME=${REGION}-ecr-registry
EMAIL=anymail.doesnt.matter@email.com
TOKEN=$(aws ecr get-login --region ${REGION} --registry-ids ${ACCOUNT} | cut -d' ' -f6)
echo &amp;quot;ENV variables setup done.&amp;quot;
kubectl -n ${NAMESPACE} delete secret --ignore-not-found $SECRET_NAME
kubectl -n ${NAMESPACE} create secret docker-registry $SECRET_NAME \
--docker-server=https://${ACCOUNT}.dkr.ecr.${REGION}.amazonaws.com \
--docker-username=AWS \
--docker-password=&amp;quot;${TOKEN}&amp;quot; \
--docker-email=&amp;quot;${EMAIL}&amp;quot;
echo &amp;quot;Secret created by name $SECRET_NAME&amp;quot;
kubectl -n ${NAMESPACE} patch serviceaccount ${SERVICE_ACCOUNT} -p '{&amp;quot;imagePullSecrets&amp;quot;:[{&amp;quot;name&amp;quot;:&amp;quot;'$SECRET_NAME'&amp;quot;}]}'
echo &amp;quot;All done.&amp;quot;
image: odaniait/aws-kubectl:latest
imagePullPolicy: IfNotPresent
name: ecr-cred-helper
resources: {}
securityContext:
capabilities: {}
terminationMessagePath: /dev/termination-log
terminationMessagePolicy: File
dnsPolicy: Default
hostNetwork: true
restartPolicy: Never
schedulerName: default-scheduler
securityContext: {}
terminationGracePeriodSeconds: 30
&lt;/code>&lt;/pre>
&lt;p>En el fichero anterior, dependiendo de nuestra configuración particular, podremos cambiar el valor de las variables &lt;code>NAMESPACE&lt;/code> y &lt;code>SERVICE_ACCOUNT&lt;/code>, y también especificar manualmente las variables &lt;code>ACCOUNT&lt;/code> y &lt;code>REGION&lt;/code> si no queremos que el script las auto-detecte porque usamos otras en concreto.&lt;/p>
&lt;p>Básicamente, lo que hace esto, es crear un trabajo de cron, que lanza un contenedor y ejecuta el script en Bash definido en la especificación del pod. En resumen:&lt;/p>
&lt;ul>
&lt;li>Obtiene las credenciales de acceso a ECR utilizando la cli de AWS&lt;/li>
&lt;li>Elimina, si existe, el secreto llamado &lt;code>${REGION}-ecr-registry&lt;/code>&lt;/li>
&lt;li>Lo crea de nuevo, con el token obtenido de ECR&lt;/li>
&lt;li>Actualiza la service account de AWX indicándole que para obtener las imágenes (&lt;code>imagePullSecrets&lt;/code>) tiene usar las credenciales del secreto recién creado&lt;/li>
&lt;/ul>
&lt;p>Tras esto, importamos la definición del job en Kubernetes:&lt;/p>
&lt;pre>&lt;code class="language-bash">kubectl -n awx apply -f ecr-cred-refresh.yml
&lt;/code>&lt;/pre>
&lt;p>Este job se ejecuta cada 6 horas; si queremos forzar la ejecución, podemos hacerlo con los siguientes comandos:&lt;/p>
&lt;pre>&lt;code class="language-bash">JOB_NAME=&amp;quot;manual-$(date --utc +%Y%m%d-%H%M%S)&amp;quot;
kubectl -n awx create job --from=cronjob/ecr-cred-helper ${JOB_NAME}
kubectl -n awx wait --for=condition=complete job.batch/${JOB_NAME}
kubectl -n awx logs job.batch/${JOB_NAME}
&lt;/code>&lt;/pre>
&lt;p>Pero esto por sí solo no nos vale&amp;hellip; porque ¿dónde le decimos las crendenciales para acceder a AWS (es decir, para que desde dentro del cronjob se pueda hacer &lt;code>aws ecr get-login&lt;/code>)? Es decir, el access key y el secret. Para esto, no le pasaremos una key y un secret, sino que crearemos un rol y se lo asignaremos a la instancia EC2 de AWS donde estemos ejecutando Microk8s. El rol debe tener una policy que permita a la instancia acceder al repositorio; podemos usar la policy predefinida &lt;code>AmazonEC2ContainerRegistryReadOnly&lt;/code> o crear una manualmente.&lt;/p>
&lt;p>Tras crear el rol y la policy, y asignar el rol a la instancia, podemos ejecutar manualmente el &lt;code>cronjob&lt;/code>, y ejecutar de nuevo el instalador de AWX, que ya debería obtener la imagen de Docker sin problemas.&lt;/p>
&lt;p>Comandos útiles:&lt;/p>
&lt;pre>&lt;code class="language-bash"># Ver información de la service account de awx
kubectl -n awx describe serviceaccounts awx
# Ver información de los secretos (cuándo se actualizó/obtuvo el token por última vez)
kubectl -n awx get secrets
&lt;/code>&lt;/pre>
&lt;p>Probar manualmente el script:&lt;/p>
&lt;pre>&lt;code class="language-bash">kubectl run -i --tty --rm debug --image=odaniait/aws-kubectl:latest --restart=Never -- sh
kubectl run --generator=run-pod/v1 -n awx --rm -i --tty compass-tmp --image=odaniait/aws-kubectl:latest -- sh
&lt;/code>&lt;/pre>
&lt;p>Referencias:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="https://medium.com/@damitj07/how-to-configure-and-use-aws-ecr-with-kubernetes-rancher2-0-6144c626d42c" target="_blank" rel="noopener">How to configure and use AWS ECR with kubernetes &amp;amp; Rancher2.0&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>