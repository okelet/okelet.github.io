<!doctype html><html lang=es><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Probando Ansible AWX con MicroK8s - Mis notas</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Juan Asensio"><meta name=description content="AVISO: Post largo (intro a Ansible, AWX, MicroK8s)
Actualización 2020-01-14: Actualizado a Ansible AWX 9.1.1
Ansible (/ánsibol/) es el gestor de configuración de moda, y por méritos propios. Aunque no es perfecto (en determinadas ocasiones se puede preferir un modelo cliente/servidor en lugar de una conexión SSH ad-hoc), ofrece una buena combinación entre funcionalidad y simplicidad. Siempre y cuando tengamos conectividad SSH con la máquina a gestionar (o no, a través de bastiones), en el caso de equipos Linux, o conectividad WinRM o o PSRP para equipos Windows, podremos realizar infinidad de acciones o tareas sobre las máquinas a gestionar.
Uno de los problemas de Ansible (hablando correctamente, Ansible Engine) es que no tiene una forma de ejecutar de forma automatizada playbooks, para mantener la configuración sincronizada de forma periódica, ejecutar tareas planificadas o incluso auto-provisionar equipos. Aquí es donde entra Ansible Tower, que es la versión con soporte de Ansible AWX, al estilo de lo que Red Hat hace con Wildfly y JBoss. Ansible Tower/AWX en básicamente una API REST con una interfaz web que se comunica con ella. Utilizando esta API, se pueden definir inventarios, credenciales, equipos, plantillas de trabajo, flujos de trabajo, etc. así como asignar permisos por usarios/grupos mediante su sistema RBAC."><meta name=keywords content="okelet,linux,bash,python,aws,google,cloud,gcloud"><meta name=generator content="Hugo 0.64.1 with even 4.0.0"><link rel=canonical href=https://okelet.netlify.com/posts/2019/06/probando-ansible-awx-con-microk8s/><link href=https://okelet.netlify.com/atom.xml type=application/atom+xml rel=alternate title="Mis notas - Atom"><link href=https://okelet.netlify.com/index.xml type=application/rss+xml rel=alternate title="Mis notas - RSS"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/dist/even.c2a46f00.min.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=https://okelet.netlify.com/css/custom.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.9.0/css/all.css><meta property="og:title" content="Probando Ansible AWX con MicroK8s"><meta property="og:description" content="AVISO: Post largo (intro a Ansible, AWX, MicroK8s)
Actualización 2020-01-14: Actualizado a Ansible AWX 9.1.1
Ansible (/ánsibol/) es el gestor de configuración de moda, y por méritos propios. Aunque no es perfecto (en determinadas ocasiones se puede preferir un modelo cliente/servidor en lugar de una conexión SSH ad-hoc), ofrece una buena combinación entre funcionalidad y simplicidad. Siempre y cuando tengamos conectividad SSH con la máquina a gestionar (o no, a través de bastiones), en el caso de equipos Linux, o conectividad WinRM o o PSRP para equipos Windows, podremos realizar infinidad de acciones o tareas sobre las máquinas a gestionar.
Uno de los problemas de Ansible (hablando correctamente, Ansible Engine) es que no tiene una forma de ejecutar de forma automatizada playbooks, para mantener la configuración sincronizada de forma periódica, ejecutar tareas planificadas o incluso auto-provisionar equipos. Aquí es donde entra Ansible Tower, que es la versión con soporte de Ansible AWX, al estilo de lo que Red Hat hace con Wildfly y JBoss. Ansible Tower/AWX en básicamente una API REST con una interfaz web que se comunica con ella. Utilizando esta API, se pueden definir inventarios, credenciales, equipos, plantillas de trabajo, flujos de trabajo, etc. así como asignar permisos por usarios/grupos mediante su sistema RBAC."><meta property="og:type" content="article"><meta property="og:url" content="https://okelet.netlify.com/posts/2019/06/probando-ansible-awx-con-microk8s/"><meta property="article:published_time" content="2019-06-19T00:00:00+00:00"><meta property="article:modified_time" content="2020-01-18T00:00:00+00:00"><meta itemprop=name content="Probando Ansible AWX con MicroK8s"><meta itemprop=description content="AVISO: Post largo (intro a Ansible, AWX, MicroK8s)
Actualización 2020-01-14: Actualizado a Ansible AWX 9.1.1
Ansible (/ánsibol/) es el gestor de configuración de moda, y por méritos propios. Aunque no es perfecto (en determinadas ocasiones se puede preferir un modelo cliente/servidor en lugar de una conexión SSH ad-hoc), ofrece una buena combinación entre funcionalidad y simplicidad. Siempre y cuando tengamos conectividad SSH con la máquina a gestionar (o no, a través de bastiones), en el caso de equipos Linux, o conectividad WinRM o o PSRP para equipos Windows, podremos realizar infinidad de acciones o tareas sobre las máquinas a gestionar.
Uno de los problemas de Ansible (hablando correctamente, Ansible Engine) es que no tiene una forma de ejecutar de forma automatizada playbooks, para mantener la configuración sincronizada de forma periódica, ejecutar tareas planificadas o incluso auto-provisionar equipos. Aquí es donde entra Ansible Tower, que es la versión con soporte de Ansible AWX, al estilo de lo que Red Hat hace con Wildfly y JBoss. Ansible Tower/AWX en básicamente una API REST con una interfaz web que se comunica con ella. Utilizando esta API, se pueden definir inventarios, credenciales, equipos, plantillas de trabajo, flujos de trabajo, etc. así como asignar permisos por usarios/grupos mediante su sistema RBAC."><meta itemprop=datePublished content="2019-06-19T00:00:00+00:00"><meta itemprop=dateModified content="2020-01-18T00:00:00+00:00"><meta itemprop=wordCount content="1405"><meta itemprop=keywords content="Ansible,AWX,Kubernetes,MicroK8s,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Probando Ansible AWX con MicroK8s"><meta name=twitter:description content="AVISO: Post largo (intro a Ansible, AWX, MicroK8s)
Actualización 2020-01-14: Actualizado a Ansible AWX 9.1.1
Ansible (/ánsibol/) es el gestor de configuración de moda, y por méritos propios. Aunque no es perfecto (en determinadas ocasiones se puede preferir un modelo cliente/servidor en lugar de una conexión SSH ad-hoc), ofrece una buena combinación entre funcionalidad y simplicidad. Siempre y cuando tengamos conectividad SSH con la máquina a gestionar (o no, a través de bastiones), en el caso de equipos Linux, o conectividad WinRM o o PSRP para equipos Windows, podremos realizar infinidad de acciones o tareas sobre las máquinas a gestionar.
Uno de los problemas de Ansible (hablando correctamente, Ansible Engine) es que no tiene una forma de ejecutar de forma automatizada playbooks, para mantener la configuración sincronizada de forma periódica, ejecutar tareas planificadas o incluso auto-provisionar equipos. Aquí es donde entra Ansible Tower, que es la versión con soporte de Ansible AWX, al estilo de lo que Red Hat hace con Wildfly y JBoss. Ansible Tower/AWX en básicamente una API REST con una interfaz web que se comunica con ella. Utilizando esta API, se pueden definir inventarios, credenciales, equipos, plantillas de trabajo, flujos de trabajo, etc. así como asignar permisos por usarios/grupos mediante su sistema RBAC."><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--><link rel=stylesheet type=text/css href=https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.css><script src=https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.js></script><script>window.addEventListener("load",function(){window.cookieconsent.initialise({"palette":{"popup":{"background":"#000"},"button":{"background":"#f1d600"}},"theme":"classic"})});</script></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Mis notas</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Inicio</li></a><a href=/posts/><li class=mobile-menu-item>Archivos</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/pages/projects/><li class=mobile-menu-item>Proyectos</li></a><a href=/pages/about/><li class=mobile-menu-item>Acerca de</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Mis notas</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Inicio</a></li><li class=menu-item><a class=menu-item-link href=/posts/>Archivos</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/pages/projects/>Proyectos</a></li><li class=menu-item><a class=menu-item-link href=/pages/about/>Acerca de</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Probando Ansible AWX con MicroK8s</h1><div class=post-meta><span class=post-time>2019-06-19</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contenidos</h2><div class="post-toc-content always-active"><nav id=TableOfContents></nav></div></div><div class=post-content><p>AVISO: Post largo (intro a Ansible, AWX, MicroK8s)</p><p>Actualización 2020-01-14: Actualizado a <a href=https://groups.google.com/forum/#!topic/awx-project/aYYtuAuHMzY>Ansible AWX 9.1.1</a></p><p>Ansible (<em>/ánsibol/</em>) es el gestor de configuración de moda, y por méritos propios. Aunque no es perfecto (en determinadas ocasiones se puede preferir un modelo cliente/servidor en lugar de una conexión SSH <em>ad-hoc</em>), ofrece una buena combinación entre funcionalidad y simplicidad. Siempre y cuando tengamos conectividad SSH con la máquina a gestionar (o no, a través de <a href=https://docs.aws.amazon.com/es_es/quickstart/latest/linux-bastion/architecture.html>bastiones</a>), en el caso de equipos Linux, o conectividad WinRM o o PSRP para equipos Windows, podremos realizar infinidad de acciones o tareas sobre las máquinas a gestionar.</p><p>Uno de los problemas de Ansible (hablando correctamente, <a href=https://www.ansible.com/blog/red-hat-ansible-automation-engine-vs-tower>Ansible Engine</a>) es que no tiene una forma de ejecutar de forma automatizada playbooks, para mantener la configuración sincronizada de forma periódica, ejecutar tareas planificadas o incluso auto-provisionar equipos. Aquí es donde entra Ansible Tower, que es la versión con soporte de <a href=https://github.com/ansible/awx>Ansible AWX</a>, al estilo de lo que Red Hat hace con Wildfly y JBoss. Ansible Tower/AWX en básicamente una API REST con una interfaz web que se comunica con ella. Utilizando esta API, se pueden definir inventarios, credenciales, equipos, plantillas de trabajo, flujos de trabajo, etc. así como asignar permisos por usarios/grupos mediante su sistema RBAC.</p><p>He de reconocer que al principio cuesta un poco, pero cuando se le pilla el truco, uno se da cuenta de lo potente que es. Pero lo que no me explico es la complejidad de instalación del software. Creo que Red Hat se está empeñando en poner las cosas difíciles a quienes usan sus productos sin suscripción (que al final son los que en gran medida depuran el software, contribuyen de forma gratuita, etc.); en este caso, se nos obliga a hacer una instalación mediante Docker, que aunque está de moda, que lo veo muy bien, creo que deberían dar alternativas (que sí que las dan con la versión con soporte, por lo que impedimentos técnicos no los hay, simplemente es intencionalidad). Para la versión libre (AWX) se soportan los siguientes <a href=https://github.com/ansible/awx/blob/devel/INSTALL.md>métodos de instalación</a>:</p><ul><li>Openshift (claramente enfocado a utilizar un stack completo de Red Hat)</li><li>Docker Compose</li><li>Kubernetes</li></ul><p>En cambio, para Tower, la versión con soporte, es básicamente un script de instalación, que la verdad no he probado, aunque me imagino que lo que hace es provisionar los nodos con el software necesario, a la antigua usanza (no sé si por debajo creará un cluster de K8s u Openshift, o directamente lo hace sobre el sistema operativo).</p><p>Básicamente, la forma de instalación de AWX es crear una serie de contenedores en el orquestador en cuestión (AWX task, AWX web, RabbitMQ, Postgres, Memcached).</p><p>Con ideas de probar AWX para un proyecto interno, empecé a analizar las 3 opciones de instalación; la primera de ellas, Openshift, la descarté desde el principio por ser una tecnología no muy extendida, en favor, en todo caso, de Kubernetes. Ya que esto era una <a href=https://es.wikipedia.org/wiki/Prueba_de_concepto>PoC</a>, no quería complicarme mucho con Kubernetes, por lo que empecé a probar con Docker Compose, pero a la hora de escalar, lanzando la instalación en varios nodos, me di cuenta de que el modo de funcionar de AWX requiere un cluster de <a href=https://www.rabbitmq.com/>RabbitMQ</a>, que es difícil de configurar dinámicamente con Docker Compose. Con Kubernetes y su <a href=https://github.com/ansible/awx/blob/devel/installer/roles/kubernetes/templates/deployment.yml.j2#L38>&ldquo;magia&rdquo;</a> hace que el cluster de RabbitMQ se configure y escale automáticamente.</p><p>Siendo mi única opción Kubernetes, no quería montarme un cluster por mi cuenta, ni tener que montar un cluster de EKS, que <a href=https://aws.amazon.com/es/eks/pricing/>de base ya son 144$ al mes</a> más los nodos de computación, al final tuve que buscar alternativas más simples.</p><p>Mi primera intención fue probar <a href=https://kubernetes.io/es/docs/tasks/tools/install-minikube/>Minikube</a> en mi máquina local, pero cada pod de AWX consume 6 GB de RAM, por lo que mínimo a la MV de Minikube le tenía que dar 7 GB, y teniendo mi portátil 8 GB, murió varias veces en el intento&mldr; Me planteé montar Minikube en una instancia EC2, pero esto sería montar Virtualbox, sobre un entorno ya virtualizado (EC2), y sobre el que correría Kubernetes&mldr; Aunque factible, me parecía un poco engorroso. Así que gracias a mi compañero Roque, que me recordó la existencia de <a href=https://microk8s.io/>MicroK8s</a>, me decidí a probar.</p><p>Partiendo de una EC2 con Ubuntu 18.04 limpia, estos son los comandos a ejecutar para montar un entorno de Ansible AWX con MicroK8s (forzamos la versión 1.15, ya que AWX no es compatible con una versión mayor, por ahora):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>sudo snap refresh microk8s --channel 1.15/stable
sudo snap install helm --channel<span class=o>=</span>2.16/stable --classic

<span class=o>(</span>grep <span class=s2>&#34;</span><span class=s2>^--allow-privileged</span>$<span class=s2>&#34;</span> /var/snap/microk8s/current/args/kube-apiserver &gt; /dev/null<span class=o>)</span> <span class=o>||</span> <span class=o>(</span><span class=nb>echo</span> <span class=s2>&#34;--allow-privileged&#34;</span> <span class=p>|</span> sudo tee -a /var/snap/microk8s/current/args/kube-apiserver<span class=o>)</span>
<span class=o>(</span>grep <span class=s2>&#34;</span><span class=s2>^--allow-privileged</span>$<span class=s2>&#34;</span> /var/snap/microk8s/current/args/kubelet &gt; /dev/null<span class=o>)</span> <span class=o>||</span> <span class=o>(</span><span class=nb>echo</span> <span class=s2>&#34;--allow-privileged&#34;</span> <span class=p>|</span> sudo tee -a /var/snap/microk8s/current/args/kubelet<span class=o>)</span>
sudo microk8s.stop
sudo microk8s.start

microk8s.enable ingress
microk8s.enable dns
microk8s.enable storage
sudo snap <span class=nb>alias</span> microk8s.kubectl kubectl
microk8s.config &gt; <span class=nv>$HOME</span>/.kube/config
helm init
</code></pre></td></tr></table></div></div><p><a href=https://helm.sh/>Helm</a> es necesario para instalación de Postgres; si vamos a utilizar una BBDD externa, no es necesario.</p><p>Tras esto, ya tenemos el entorno de MicroK8s disponible; ahora nos bajamos AWX y lo configuramos:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash><span class=c1># Actualizar e instalar dependencias mínimas</span>
sudo apt update
sudo apt upgrade -y
sudo apt install -y python3-pip vim
pip3 install docker docker-compose --user

<span class=c1># Instalar Ansible, necesario para instalar AWX</span>
sudo add-apt-repository ppa:ansible/ansible -y
sudo apt update
sudo apt install -y ansible

<span class=c1># Nos bajamos la release 9.1.1 de AWX</span>
curl -sLO https://github.com/ansible/awx/archive/9.1.1.tar.gz
tar zxf 9.1.1.tar.gz
<span class=nb>cd</span> awx-9.1.1/installer
cp -a inventory<span class=o>{</span>,.original<span class=o>}</span>

<span class=c1># Configuramos el fichero de inventario para que use Kubernetes</span>
sed -i -e <span class=s1>&#39;s/#* *kubernetes_context.*/kubernetes_context=microk8s/&#39;</span> inventory
sed -i -e <span class=s1>&#39;s/#* *kubernetes_namespace.*/kubernetes_namespace=awx/&#39;</span> inventory

<span class=c1># Y lanzamos la instalación</span>
ansible-playbook -i inventory install.yml
</code></pre></td></tr></table></div></div><p>Variables interesantes en el fichero <code>inventory</code>:</p><ul><li><code>kubernetes_context</code>: el contexto del cliente de Kubernetes que usaremos para conectarnos al cluster; para MicroK8s, en general será <code>microk8s</code>.</li><li><code>kubernetes_namespace</code>: el <em>namespace</em> del cluster de Kubernetes que se usará para crear todos los elementos de AWX; por defecto es <code>awx</code>.</li><li><code>kubernetes_deployment_name</code>: es un prefijo que se usa para generar los nombres de los recursos dentro del <em>namespace</em>; por defecto es <code>awx</code>.</li><li><code>pg_hostname</code>: es el host remoto donde debemos tener instalado un servidor de Postgres; si esta variable está comentada, el instalador creará un servidor de Postgres en Kubernetes usando Helm; si está definida, se usará el servidor indicado (habrá que configurar adecuadamente el resto de parámetros de conexión a la BBDD: <code>pg_username</code>, <code>pg_password</code>, <code>pg_database</code>, etc.).</li></ul><p>También se pueden especificar las siguientes variables para indicar imágenes y versiones alternativas a las oficiales (por ejemplo, si hemos creado unas propias para añadir software, etc.):</p><ul><li><code>kubernetes_task_version</code> (por defecto: <code>9.1.1</code>)</li><li><code>kubernetes_task_image</code> (por defecto: <code>ansible/awx_task</code>)</li><li><code>kubernetes_web_version</code> (por defecto: <code>9.1.1</code>)</li><li><code>kubernetes_web_image</code> (por defecto: <code>ansible/awx_web</code>)</li></ul><p>Esto nos creará un namespace llamado <code>awx</code> en MicroK8s, y desplegará en él 2 <code>statefulsets</code>: 1 para Postgres y uno para AWX. Cada <code>statefulset/pod</code> de AWX contiene los siguientes contenedores:</p><ul><li>memcached</li><li>rabbitmq</li><li>awx-celery (awx_task)</li><li>awx-web</li></ul><p>Cada vez que se escala el <code>statefulset</code> se crean estos 4 contenedores. Gracias al plugin <a href=https://github.com/rabbitmq/rabbitmq-peer-discovery-k8s><code>rabbitmq_peer_discovery_k8s</code></a> (<a href=https://github.com/ansible/awx/blob/devel/installer/roles/kubernetes/templates/deployment.yml.j2#L38>aquí</a> se puede ver fichero YAML de configuración) los contenedores de rabbitmq forman un cluster de forma automática.</p><p>Para volver a empezar desde 0, tenemos 2 posibilidades; o bien borrar el <em>namespace</em>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>kubectl delete namespaces awx
</code></pre></td></tr></table></div></div><p>O bien con el comando <code>microk8s.reset</code>, aunque con este comando, frecuentemente se queda &ldquo;colgado&rdquo;:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>microk8s.reset
</code></pre></td></tr></table></div></div><p>Después del reset, es necesario volver a configurar los complementos (dns, storage, ingress), y configurar el cliente:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>microk8s.enable ingress
microk8s.enable dns
microk8s.enable storage
sudo snap <span class=nb>alias</span> microk8s.kubectl kubectl
microk8s.config &gt; <span class=nv>$HOME</span>/.kube/config
helm init
</code></pre></td></tr></table></div></div><p>Y podemos lanzar de nuevo la instalación:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>ansible-playbook -i inventory install.yml
</code></pre></td></tr></table></div></div><p>Si por delante del servidor vamos a poner un balanceador (por ejemplo, un ELB o ALB), debemos configurar el <code>ingress</code> de Nginx para que reenvíe las cabeceras <code>X-Forwarded-*</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-bash data-lang=bash>kubectl -n default edit configmaps nginx-load-balancer-microk8s-conf
</code></pre></td></tr></table></div></div><p>Añadiendo/modificando la sección data con este valor:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-yaml data-lang=yaml><span class=k>data</span><span class=p>:</span><span class=w>
</span><span class=w></span><span class=w>    </span><span class=k>use-forwarded-headers</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;true&#34;</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>Esto es necesario, por ejemplo, si se usa un balanceador con HTTPS, y configuramos la autentificación de Azure, ya que sin el reenvío de estas cabeceras, AWX se cree que vamos por HTTP en lugar de HTTPS, y la URL de callback para el login de Azure se genera incorrectamente.</p><p>Una vez realizados los pasos de la instalación, lo único que nos queda es acceder a la aplicación, usando el puerto 80 de la máquina, por ejemplo, <a href=http://localhost>http://localhost</a>, que es donde publica los servicios el <em>ingress controller</em> de nginx.</p></div><footer class=post-footer><div class=post-tags><a href=/tags/ansible/>Ansible</a>
<a href=/tags/awx/>AWX</a>
<a href=/tags/kubernetes/>Kubernetes</a>
<a href=/tags/microk8s/>MicroK8s</a></div><nav class=post-nav><a class=prev href=/posts/2019/06/crear-usuario-y-base-de-datos-en-postgres-y-dar-permisos/><i class="iconfont icon-left"></i><span class="prev-text nav-default">Crear usuario y base de datos en Postgres y dar permisos</span>
<span class="prev-text nav-mobile">Previo</span></a>
<a class=next href=/posts/2019/06/crear-un-rol-personalizado-en-google-cloud-para-encendido-y-apagado-de-m%C3%A1quinas/><span class="next-text nav-default">Crear un rol personalizado en Google Cloud para encendido y apagado de máquinas</span>
<span class="next-text nav-mobile">Siguiente</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname==='localhost')return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='okeletgithubio';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=https://stackoverflow.com/users/576138/okelet class="iconfont icon-stack-overflow" title=stack-overflow></a><a href=https://www.linkedin.com/in/okelet/ class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/okelet/ class="iconfont icon-github" title=github></a><a href=https://gitlab.com/okelet class="iconfont icon-gitlab" title=gitlab></a><a href=https://okelet.netlify.com/atom.xml type=application/atom+xml class="iconfont icon-rss" title="Atom feed"></a></div><div class=copyright><span class=power-by>Creado con <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Tema -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2020
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>Juan Asensio</span></span></div><script type=text/javascript>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(54019648,"init",{clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src=https://mc.yandex.ru/watch/54019648 style=position:absolute;left:-9999px alt></div></noscript></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin=anonymous></script><script>var languageCode="es".replace(/-/g,'_').replace(/_(.*)/,function($0,$1){return $0.replace($1,$1.toUpperCase());});timeago().render(document.querySelectorAll('.timeago'),languageCode);timeago.cancel();</script><script type=text/javascript src=/dist/even.26188efa.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-53728915-2','auto');ga('set','anonymizeIp',true);ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=/js/custom.js></script></body></html>